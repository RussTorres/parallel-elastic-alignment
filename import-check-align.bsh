/**
 * Call
 *
 * xvfb-run -a ./ImageJ-linux64 -Ddir=<project directory> -Dfile=<import file>  -- --no-splash import-and-align.bsh
 *
 * on the cluster with absolute paths, e.g.
 *
 * ${HOME}/bin/xvfb-run -a ${HOME}/packages/Fiji.app/fiji-linux64 \
 *   -Xms10g -Xmx10g -Ddir=${HOME}/AL-FIB-Z0712-12/0-99 \
 *   -Dfile=${HOME}/AL-FIB-Z0712-12/0-99/import.txt  -- --no-splash \
 *   ${HOME}/AL-FIB-Z0712-12/AL-FIB-Z0712-12/import-and-align.bsh
 * 
 * @author Stephan Saalfeld <saalfeld@mpi-cbg.de>
 */

import ij.*;
import ini.trakem2.display.*;

import ini.trakem2.ControlWindow;
import ini.trakem2.Project;
import ini.trakem2.utils.Filter;
import java.lang.Runtime;
import java.util.ArrayList;
import java.util.HashSet;
import mpicbg.trakem2.align.ElasticLayerAlignment;
import mpicbg.trakem2.align.RegularizedAffineLayerAlignment;

boolean backupProject( dir, suffix ) {
	Exception f = null;
	for (int i = 0; i < 10; ++i) {
		try {
            r = Runtime.getRuntime();
            p = r.exec( "cp -v " + dir + "/project.xml " + dir + "/project." + suffix + ".xml" );
            exitStatus = p.waitFor();
			if ( exitStatus == 0 )
				return true;
		}
		catch (e) {
			f = e;
			f.printStackTrace();
		}
		System.out.println("Trial " + i + ", failed to backup project in \"" + dir + "\".");
		Thread.sleep(1000);
	}
	if (f == null)
		return false;
	else
		throw f;
}

try {
	runtime = Runtime.getRuntime();
	System.out.println( runtime.availableProcessors() + " cores available for multi-threading" );
	
	dir = System.getProperty("dir");
	file = System.getProperty("file");

    parentdir = dir.substring( 0, dir.lastIndexOf('/'));
    preprocessorFile = parentdir + "/pad-noise.bsh";
	
	ControlWindow.setGUIEnabled(false);
	project = Project.newFSProject("blank", null, dir, false);
	loader = project.getLoader();
	layerset = project.getRootLayerSet();
	layerset.setSnapshotsMode(1);
	
	/* add a reference layer (pointless gymnastik) */
	layer = new Layer(project, 0, 1, layerset);
	layerset.add(layer);
	layer.recreateBuckets();
	
    System.out.println("Load images");
	/* import images */ task = loader.importImages(
			layerset.getLayer(0),	// the first layer
			file,					// the absolute file path to the text file with absolute image file paths
			" ",					// the column separator  <path> <x> <y> <section index>
			1.0,					// section thickness, defaults to 1
			1.0,					// calibration, defaults to 1
			false,					// whether to homogenize contrast, avoid
			1.0f,					// scaling factor, default to 1
			0);						// border width
	
	/* wait until all images have been imported */
	task.join();
	

	/* scan through layers */
    System.out.println(" CHECKING  " );
    anyMissingLayers = false;
    ii = 0;
    lastZ = -1; 
	for (layer : layerset.getLayers()) {
        if ( ii > 0 ){
            if( layer.getZ() != (lastZ+1)){
                System.out.println("  " + lastZ + " missing");
                anyMissingLayers = true;
            }
        }
        ii++;

        lastZ = layer.getZ();
		patches = layer.getDisplayables(Patch.class);
		if (patches.size() < 1){
			System.out.println("  " + layer.getZ() + " missing");
            anyMissingLayers = true;
        }
	}

    if( anyMissingLayers ) { 
        System.out.println( "FAIL - MISSING LAYERS" );
        runtime.exit(1);
    }

    System.out.println("preemptive SAVE");
	/* save the project */
    project.saveAs(dir + "/project.xml", false);
    
    didBackup = backupProject( dir, "import" );

    //System.out.println( "exiting early for debug ");
    //System.out.println("TASK COMPLETE");
    //runtime.exit(0);

    System.out.println("add preprocessor");
    /* Add preprocessor */
    for ( p : layerset.getDisplayables( Patch.class ) )
    {
        System.out.println("add preprocessor for " + p );
        project.getLoader().setPreprocessorScriptPath( p, preprocessorFile );
    } 

    System.out.println("MIPMAP REGENERATION POST-PREPROCESSOR!");
	/* wait until all mipmaps are generated */
	futures = new ArrayList();
	for (p : layerset.getDisplayables(Patch.class))
		futures.add(p.updateMipMaps());
	for (f : futures)
		f.get();

    System.out.println("SAVE");
	/* save the project */
    project.saveAs(dir + "/project.xml", false);
    didBackup = backupProject( dir, "preproc" );
    
	/* delete reference layer if it was not part of the import range */
	l0 = layerset.getLayer(0);
	if (l0.getDisplayables(Patch.class).size() == 0)
		layerset.remove(l0);
	
	layerset.setMinimumDimensions();


	/* prepare alignment */
	layerRange = layerset.getLayers();
	fixedLayers = new HashSet();
	emptyLayers = new HashSet();
	
	filter = new Filter() {
		public boolean accept(Patch patch) {
			return patch.isVisible();
			}
		};
	
	/* affine alignment */
	paramAffine = new RegularizedAffineLayerAlignment.Param();
	
	paramAffine.ppm.sift.initialSigma = 1.6f;
	paramAffine.ppm.sift.steps = 3;
	paramAffine.ppm.sift.minOctaveSize = 200;
	paramAffine.ppm.sift.maxOctaveSize = 1024;
	paramAffine.ppm.sift.fdSize = 4;
	paramAffine.ppm.sift.fdBins = 8;
	paramAffine.ppm.rod = 0.92f;
	paramAffine.ppm.clearCache = true;
	paramAffine.ppm.maxNumThreadsSift = 3; //runtime.availableProcessors();
	
	paramAffine.maxEpsilon = 50.0f;
	paramAffine.minInlierRatio = 0.0f;
	paramAffine.minNumInliers = 12;
	paramAffine.expectedModelIndex = 0;
	paramAffine.multipleHypotheses = true;
	paramAffine.rejectIdentity = false;
	paramAffine.identityTolerance = 0.0f;
	paramAffine.maxNumNeighbors = 10;
	paramAffine.maxNumFailures = 3;
	paramAffine.maxNumThreads = 3; //runtime.availableProcessors();
	
	paramAffine.desiredModelIndex = 3;
	paramAffine.regularize = true;
	paramAffine.maxIterationsOptimize = 2000;
	paramAffine.maxPlateauwidthOptimize = 2000;
	paramAffine.regularizerIndex = 0;
	paramAffine.visualize = false;
	
	paramAffine.lambda = 0.1f;
	
	new RegularizedAffineLayerAlignment().exec(
			paramAffine,
			layerRange,	
			fixedLayers,
			emptyLayers,
			layerset.get2DBounds(),
			false,
			false,
			filter);
	
	paramAffine.lambda = 0.01f;
	
	layerset.setMinimumDimensions();
	
	new RegularizedAffineLayerAlignment().exec(
			paramAffine,
			layerRange,	
			fixedLayers,
			emptyLayers,
			layerset.get2DBounds(),
			false,
			false,
			filter);
	
	layerset.setMinimumDimensions();
		
	/* save the project */
	project.saveAs(dir + "/project.xml", true);
    didBackup = backupProject( dir, "affine" );

	/* elastic alignment */
	paramElastic = new ElasticLayerAlignment.Param();
	
	paramElastic.layerScale = 0.25f;
	paramElastic.searchRadius = 15;
	paramElastic.blockRadius = 300;
	paramElastic.resolutionSpringMesh = 24; //(int)Math.ceil((double)layerset.get2DBounds().width / 8192.0 * 32.0);
	
	paramElastic.minR = 0.6f;
	paramElastic.maxCurvatureR = 10.0f;
	paramElastic.rodR = 1.0f; //0.92f;
	
	paramElastic.useLocalSmoothnessFilter = true;
	paramElastic.localModelIndex = 3;
	paramElastic.localRegionSigma = 500.0f;
	paramElastic.maxLocalEpsilon = 5.0f;
	paramElastic.maxLocalTrust = 3.0f;
	
	paramElastic.isAligned = true;
	paramElastic.maxNumFailures = 3;
	paramElastic.maxNumNeighbors = 12;
	paramElastic.maxNumThreads = 3; //8;
	
	paramElastic.desiredModelIndex = 1;
	paramElastic.maxIterationsOptimize = 1000;
	paramElastic.maxPlateauwidthOptimize = 200;

	paramElastic.stiffnessSpringMesh = 0.10f;
	paramElastic.maxStretchSpringMesh = 2000.0f;
	paramElastic.maxIterationsSpringMesh = 1000;
	paramElastic.maxPlateauwidthSpringMesh = 200;
	paramElastic.dampSpringMesh = 0.9f;
	paramElastic.useLegacyOptimizer = false;

	new ElasticLayerAlignment().exec(
		paramElastic,
		project,
		layerRange,
		fixedLayers,
		emptyLayers,
		layerset.get2DBounds(),
		false,
		false,
		filter);
	
	/* wait until all mipmaps are generated */
	futures = new ArrayList();
	for (p : layerset.getDisplayables(Patch.class))
		futures.add(p.updateMipMaps());
	for (f : futures)
		f.get();
		
	layerset.setMinimumDimensions();
		
	/* save the project */
	project.saveAs(dir + "/project.xml", true);
    didBackup = backupProject( dir, "elastic" );

}
catch (e) {
	e.printStackTrace();
}

// Add a flag to help confirm completion
System.out.println("TASK COMPLETE");

/* shutdown */
runtime.exit(0);

